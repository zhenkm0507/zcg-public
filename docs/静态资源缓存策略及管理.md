# 静态资源缓存策略及管理

## 📋 目录

- [概述](#概述)
- [缓存策略设计](#缓存策略设计)
- [技术实现](#技术实现)
- [缓存监控管理](#缓存监控管理)
- [使用指南](#使用指南)
- [最佳实践](#最佳实践)

## 📖 概述

本文档描述了斩词阁应用的静态资源缓存策略及管理方案。通过 Service Worker 和智能缓存策略，为用户提供快速、可靠的媒体文件访问体验。

### 🎯 目标

- **性能优化**：减少网络请求，提升页面加载速度
- **离线支持**：支持离线访问已缓存的媒体文件
- **智能更新**：自动检测文件更新，确保内容最新
- **用户控制**：提供缓存管理界面，用户可自主管理

### 📁 缓存文件类型

- **音频文件**：`.mp3`, `.wav`, `.ogg`, `.m4a`
- **视频文件**：`.mp4`, `.webm`, `.ogg`, `.mov`
- **图片文件**：`.jpg`, `.jpeg`, `.png`, `.gif`, `.svg`, `.webp`
- **图标文件**：`.svg`, `.png`, `.ico`
- **根目录文件**：`apple-touch-icon.png`, `globe.svg`, `next.svg` 等

## 🎯 缓存策略设计

### 统一策略：先缓存后更新（Stale-While-Revalidate）

所有文件类型都采用统一的缓存策略，确保一致的用户体验。

#### 策略特点

1. **缓存优先**：用户请求时立即返回缓存内容，确保快速响应
2. **智能更新**：根据时间间隔后台检查更新，避免每次都网络请求
3. **条件检查**：使用 ETag、Last-Modified 等头信息判断文件是否更新
4. **用户无感**：更新过程不影响用户体验

#### 更新间隔配置

| 文件类型 | 更新间隔 | 说明 |
|---------|---------|------|
| 音频文件 | 24小时 | 音视频文件更新频率较低 |
| 视频文件 | 24小时 | 音视频文件更新频率较低 |
| 图片文件 | 7天 | 图片文件相对稳定 |
| 图标文件 | 30天 | 图标文件很少更新 |
| 根目录文件 | 7天 | 静态资源相对稳定 |

### 工作流程

```
用户请求文件
    ↓
检查是否有缓存
    ↓
有缓存 → 立即返回缓存内容
    ↓
检查是否需要更新（基于时间间隔）
    ↓
需要更新 → 后台检查文件是否真的更新了
    ↓
文件已更新 → 更新缓存，下次使用新文件
文件未更新 → 继续使用现有缓存
```

## 🔧 技术实现

### Service Worker 实现

**文件位置：** `frontend/public/sw.js`

#### 核心功能

1. **文件缓存判断**
```javascript
function shouldCacheFile(url) {
  const pathname = new URL(url).pathname;
  
  for (const [key, config] of Object.entries(CACHE_CONFIG)) {
    if (pathname.startsWith(config.path) || (config.path === '/' && pathname.startsWith('/'))) {
      const hasValidExtension = config.extensions.some(ext => 
        pathname.toLowerCase().endsWith(ext)
      );
      const isSpecificFile = config.files && config.files.some(file => 
        pathname.endsWith(file)
      );
      
      if (hasValidExtension || isSpecificFile) {
        return {
          shouldCache: true,
          strategy: config.cacheStrategy,
          updateStrategy: config.updateStrategy,
          updateInterval: config.updateInterval,
          category: key
        };
      }
    }
  }
  
  return { shouldCache: false };
}
```

2. **智能更新检查**
```javascript
function shouldCheckUpdate(url, updateInterval) {
  const lastCheckKey = `last_check_${url}`;
  const lastCheck = localStorage.getItem(lastCheckKey);
  const now = Date.now();
  
  if (!lastCheck || (now - parseInt(lastCheck)) > updateInterval) {
    localStorage.setItem(lastCheckKey, now.toString());
    return true;
  }
  
  return false;
}
```

3. **文件更新检测**
```javascript
async function isFileUpdated(request, cachedResponse) {
  try {
    const networkResponse = await fetch(request, {
      method: 'HEAD',
      cache: 'no-cache'
    });
    
    if (networkResponse.status === 304) {
      return false; // 文件未更新
    }
    
    if (networkResponse.status === 200) {
      const cachedHash = await getFileHash(cachedResponse);
      const networkHash = await getFileHash(networkResponse);
      
      return cachedHash !== networkHash;
    }
    
    return false;
  } catch (error) {
    console.warn('[SW] 检查文件更新失败:', error);
    return false;
  }
}
```

### 缓存管理工具

**文件位置：** `frontend/src/utils/cacheManager.ts`

#### 主要功能

1. **缓存信息获取**
```typescript
export async function getCacheInfo(): Promise<CacheInfo[]>
export async function getMediaFilesInfo(): Promise<MediaFileInfo[]>
export async function getCacheStats()
```

2. **缓存操作**
```typescript
export async function clearAllCaches(): Promise<void>
export async function clearCategoryCache(category: string): Promise<void>
export async function forceUpdateFile(url: string): Promise<boolean>
export async function forceUpdateCategory(category: string): Promise<number>
```

3. **工具函数**
```typescript
export function formatFileSize(bytes: number): string
export function formatUpdateInterval(interval: number): string
export function shouldCheckUpdate(url: string, updateInterval: number): boolean
```

### 缓存监控组件

**文件位置：** `frontend/src/components/CacheMonitor/`

#### 功能特性

- 📊 **统计信息展示**：总缓存大小、文件数量、类别分布
- 📋 **文件列表管理**：查看所有缓存文件的详细信息
- 🔄 **强制更新操作**：单个文件或整个类别的强制更新
- 🗑️ **缓存清理功能**：清理特定类别或所有缓存
- ⏰ **状态监控**：文件更新状态和检查时间显示

## 📊 缓存监控管理

### 页面地址

**访问地址：** `/settings/cache`

**完整URL：** `http://localhost:3000/settings/cache`

### 页面功能

#### 1. 统计信息区域

- **总缓存大小**：显示所有缓存文件的总大小
- **缓存文件数**：显示已缓存的文件总数
- **缓存数量**：显示缓存存储的数量

#### 2. 类别统计

- **音频文件**：音频文件的缓存统计和操作
- **视频文件**：视频文件的缓存统计和操作
- **图片文件**：图片文件的缓存统计和操作
- **图标文件**：图标文件的缓存统计和操作
- **根目录文件**：根目录静态资源的缓存统计和操作

每个类别显示：
- 文件数量
- 缓存大小
- 需要更新的文件数
- 更新进度条
- 更新和清理按钮

#### 3. 缓存信息表格

显示所有缓存的详细信息：
- 缓存名称
- 文件数量
- 缓存大小
- 操作按钮

#### 4. 媒体文件详情表格

显示每个缓存文件的详细信息：
- 文件路径
- 文件类别
- 文件大小
- 更新间隔
- 最后检查时间
- 更新状态
- 强制更新操作

### 操作功能

#### 强制更新

1. **单个文件更新**：点击文件列表中的"强制更新"按钮
2. **类别批量更新**：点击类别统计卡片中的"更新"按钮
3. **更新效果**：立即检查文件更新，如有更新则下载新文件

#### 缓存清理

1. **单个类别清理**：点击类别统计卡片中的"清理"按钮
2. **全部缓存清理**：点击页面顶部的"清理所有缓存"按钮
3. **清理效果**：删除指定类别的所有缓存文件

## 📖 使用指南

### 用户使用场景

#### 1. 存储空间管理

**场景**：设备存储空间不足
**操作**：
1. 访问 `/settings/cache` 页面
2. 查看各类别的缓存大小
3. 选择不需要的类别进行清理
4. 或点击"清理所有缓存"释放空间

#### 2. 文件异常修复

**场景**：音视频文件播放异常或图片显示错误
**操作**：
1. 访问缓存管理页面
2. 找到对应的文件类别
3. 点击"更新"按钮强制更新
4. 或清理该类别缓存后重新访问

#### 3. 应用性能优化

**场景**：应用运行缓慢或卡顿
**操作**：
1. 访问缓存管理页面
2. 查看缓存大小是否过大
3. 适当清理部分缓存
4. 检查是否有需要更新的文件

#### 4. 缓存状态监控

**场景**：了解应用缓存使用情况
**操作**：
1. 定期访问缓存管理页面
2. 查看统计信息和文件列表
3. 关注"需要更新"的文件
4. 根据需要执行更新或清理操作

### 管理员使用场景

#### 1. 系统维护

**场景**：服务器文件更新后，确保用户获取最新内容
**操作**：
1. 更新服务器文件
2. 通知用户访问缓存管理页面
3. 建议用户执行"检查更新"操作

#### 2. 问题排查

**场景**：用户反馈文件显示异常
**操作**：
1. 指导用户访问缓存管理页面
2. 建议清理相关类别缓存
3. 或强制更新特定文件

## 🎯 最佳实践

### 缓存策略优化

1. **合理设置更新间隔**
   - 音视频文件：24小时（更新频率低）
   - 图片文件：7天（相对稳定）
   - 图标文件：30天（很少更新）

2. **文件分类管理**
   - 按文件类型和用途分类
   - 不同类别使用不同的更新策略
   - 便于用户选择性管理

3. **智能更新机制**
   - 基于时间间隔的更新检查
   - 使用HTTP条件请求判断文件更新
   - 避免不必要的网络请求

### 用户体验优化

1. **快速响应**
   - 缓存优先策略确保快速加载
   - 后台更新不影响用户体验
   - 用户无感知的更新过程

2. **用户控制**
   - 提供详细的缓存信息
   - 支持选择性清理和更新
   - 清晰的操作反馈

3. **错误处理**
   - 网络错误时的降级处理
   - 缓存异常时的自动修复
   - 用户友好的错误提示

### 性能优化

1. **存储管理**
   - 定期清理过期缓存
   - 监控缓存大小
   - 避免缓存占用过多存储空间

2. **网络优化**
   - 减少重复的网络请求
   - 使用条件请求检查更新
   - 智能的更新策略

3. **内存管理**
   - 及时释放不需要的缓存
   - 避免内存泄漏
   - 优化缓存数据结构

### 维护建议

1. **定期监控**
   - 定期检查缓存使用情况
   - 监控缓存更新状态
   - 关注用户反馈

2. **版本管理**
   - 缓存版本号管理
   - 缓存策略版本控制
   - 向后兼容性考虑

3. **文档更新**
   - 及时更新使用文档
   - 记录策略变更
   - 维护最佳实践指南

## 🔧 技术细节

### 缓存存储结构

```
Cache Storage:
├── zcg-media-files-v1 (主要缓存)
│   ├── /audios/ (音频文件)
│   ├── /videos/ (视频文件)
│   ├── /images/ (图片文件)
│   ├── /icons/ (图标文件)
│   └── / (根目录文件)
└── 其他缓存 (Next.js 自动管理)
```

### 本地存储结构

```
localStorage:
├── last_check_/audios/login.mp3 (最后检查时间)
├── last_check_/videos/main.mp4 (最后检查时间)
└── ... (其他文件的检查时间)
```

### 错误处理机制

1. **网络错误**：返回缓存内容，后台重试
2. **缓存错误**：清理损坏的缓存，重新获取
3. **存储错误**：降级到浏览器默认缓存
4. **Service Worker 错误**：回退到无缓存模式

### 兼容性考虑

1. **浏览器支持**：检查 Service Worker 和 Cache API 支持
2. **降级处理**：不支持时使用浏览器默认缓存
3. **渐进增强**：基础功能可用，高级功能增强体验

## 📝 总结

斩词阁的静态资源缓存策略通过 Service Worker 实现了智能的缓存管理，为用户提供了快速、可靠的媒体文件访问体验。通过统一的"先缓存后更新"策略，既保证了性能，又确保了内容的及时更新。

缓存监控管理页面为用户提供了直观的缓存管理界面，支持查看缓存状态、强制更新、清理缓存等操作，让用户能够自主管理浏览器中的缓存文件。

整个缓存系统设计考虑了性能、用户体验、可维护性等多个方面，为应用提供了稳定可靠的静态资源服务。 